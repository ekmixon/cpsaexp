\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{alltt}
\input{macros}

\newcommand{\sym}[1]{\textup{\texttt{#1}}}

\title{CPSA and Formal Security Goals}
\author{John D.~Ramsdell\\
  The MITRE Corporation\\ CPSA Version \version}

\begin{document}
\maketitle
\cpsacopying

\tableofcontents

\newpage

\listoffigures

\listoftables

\newpage

\section{Introduction}

\begin{sloppypar}
Analyzing a cryptographic protocol means finding out what security
properties---essentially, authentication and secrecy properties---are
true in all its possible executions.
\end{sloppypar}

Given a protocol definition and some assumptions about executions,
{\cpsa} attempts to produce descriptions of all possible executions of
the protocol compatible with the assumptions.  Naturally, there are
infinitely many possible executions of a useful protocol, since
different participants can run it with varying parameters, and the
participants can run it repeatedly.

However, for many naturally occurring protocols, there are only
finitely many of these runs that are essentially different.  Indeed,
there are frequently very few, often just one or two, even in cases
where the protocol is flawed.  We call these essentially different
executions the \emph{shapes} of the protocol.  Authentication and
secrecy properties are easy to ``read off'' from the shapes, as are
attacks and anomalies, according to the introduction in the {\cpsa}
Primer~\cite{cpsaprimer09}.

But how easy is it to read off authentication and secrecy properties?
What precisely is it that an expert sees?  This paper describes
{\cpsa}'s support for reasoning about security goals using first-order
logic.  With security goals expressed in first-order logic, intuition
is replaced by determining if a formula is true in all executions of
the protocol.

\emph{Something about the benefits of first-order logic goes here.}

This treatment of security goals relies heavily on a branch of
first-order logic called model theory.  It deals with the relationship
between descriptions in first-order languages and the structures that
satisfy these descriptions.  In our case, the structures are skeletons
that denote a collection of executions of a protocol.  This paper
attempts to describe the language of security goals and its
structures without requiring the reader to have studied model theory.

The model theoretical foundation of this approach to security goals
appears in~\cite{Guttman14}.  The language of security goals differs
slightly from what is present here.  Section~\ref{sec:comparing}
contains a discussion on the differences between the two goal
languages.  A practical use of security goals in protocol
standardization is described in~\cite{GuttmanLiskovRowe14}.  The
precise semantics of the goal language is in~\cite{cpsaspec09}.  The
syntax of security goals appears in~\cite[Table~2]{cpsaprimer09}.

The distribution in which this paper is included contains the sample
input {\cpsa} file \texttt{goals.scm}.  It contains the examples in
this paper.  You are encouraged to run the examples and examine the
output while reading this paper.

%% Use a margin width of 62 for S-expressions

\begin{figure}
\begin{center}
\includegraphics{cpsadiagrams-0.mps}\hfil
\includegraphics{cpsadiagrams-1.mps}\\
\end{center}
\begin{center}
\begin{minipage}{3in}
\begin{verbatim}
(defprotocol ns basic
  (defrole init
    (vars (a b name) (n1 n2 text))
    (trace
     (send (enc n1 a (pubk b)))
     (recv (enc n1 n2 (pubk a)))
     (send (enc n2 (pubk b)))))
  (defrole resp
    (vars (b a name) (n2 n1 text))
    (trace
     (recv (enc n1 a (pubk b)))
     (send (enc n1 n2 (pubk a)))
     (recv (enc n2 (pubk b))))))
\end{verbatim}
\end{minipage}
\end{center}
\caption{Needham-Schroeder Initiator and Responder Roles}
\label{fig:ns roles}
\end{figure}

\begin{figure}
\begin{verbatim}
(defgoal ns                ; Goal
  (forall ((a b name) (n1 text) (z0 node))
    (implies
     (and (p "init" 2 z0) (p "init" "n1" z0 n1)
      (p "init" "a" z0 a) (p "init" "b" z0 b)
      (non (privk b)) (uniq n1))
     (exists ((z1 node))
      (and (p "resp" 1 z1) (p "resp" "b" z1 b))))))

(defskeleton ns            ; Point of view skeleton
  (vars (a b name) (n1 n2 text))
  (defstrand init 3 (a a) (b b) (n1 n1) (n2 n2))
  (non-orig (privk b))
  (uniq-orig n1))
\end{verbatim}
\begin{center}
\includegraphics{cpsadiagrams-9.mps}
\end{center}
\begin{verbatim}
(defskeleton ns            ; Shape
  (vars (n1 n2 text) (a b name))
  (defstrand init 3 (n1 n1) (n2 n2) (a a) (b b))
  (defstrand resp 2 (n2 n2-0) (n1 n1) (b b) (a a))
  (precedes ((0 0) (1 0)) ((1 1) (0 1)))
  (non-orig (privk b))
  (uniq-orig n1)
  (satisfied yes))
\end{verbatim}
\caption{Needham-Schroeder Initiator Point of View}
\label{fig:ns init}
\end{figure}

The {\cpsa} Primer~\cite{cpsaprimer09} is a prerequisite for reading
this paper.  In particular, the Needham-Schroeder Protocol in
Section~10 is reanalyzed using security goals here.  The roles are
displayed in Figure~\ref{fig:ns roles}.

The protocol is analyzed from the point of view of a complete run of
one instance of the initiator role.  The input security goal, followed
by the point of view skeleton it generates and the shape produced by
{\cpsa}, are shown in Figure~\ref{fig:ns init}.  The syntax and
semantics of the goal will be explained later.  Roughly speaking, it
asserts that if a realized skeleton contains a full length initiator
strand, its private key is uncompromised, and it uniquely generates
\texttt{n1}, then the skeleton will contain a responder strand that
agrees with the initiator on the name \texttt{b}.  The shape produced
by {\cpsa} contains the annotation \texttt{(satisfies yes)}.  This
indicates that its structure satisfies the description given by the
security goal.  It will be explained later why the properties of
{\cpsa} allows us to conclude that this goal is true in all executions
of the protocol, and therefore conclude that the Needham-Schroeder
protocol achieves this authentication goal.

\section{Syntax}\label{sec:syntax}

To be precise, a security goal is an order-sorted first-order logic
sentence in a restricted form.  The sentence in Figure~\ref{fig:ns
  init} has the form shared by all security goals.  It is a universally
quantified implication.  The antecedent is a conjunction of atomic
formulas.  For this sentence, the conclusion is an existentially
quantified conjunction of atomic formulas, but in general, the
conclusion is a disjunction of existentially quantified conjunctions
of atomic formulas.  \sym{(false)} is a synonym for \sym{(or)}.

\begin{center}\scshape
  \begin{tabular}{rcl}
  goal&$\leftarrow$&(\sym{defgoal} prot sent$+$ comments)
  \\ sent&$\leftarrow$&(\sym{forall} (decl$\ast$) (\sym{implies} antec concl))
  \\ concl&$\leftarrow$&(\sym{false})
  $\mid$ existl $\mid$ (\sym{or} existl$\ast)$
  \\ existl&$\leftarrow$&(\sym{exists}
  (decl$\ast$) antec) $\mid$ antec
  \\ antec&$\leftarrow$&atomic $\mid$ (\sym{and} atomic$\ast$)
  \end{tabular}
\end{center}

Variables are declared as they are for roles and skeletons with one
exception, there is a new sort symbol \sym{node}.  Notice that in the
sentence, variables \sym{z} and \sym{z-0} have sort \sym{node}.  Every
universally quantified variable must occur in the antecedent of the
implication.

The predicates used to construct an atomic formula (\textsc{atomic})
are listed in Table~\ref{tab:predicates}.  The first line gives the
syntax of a role position predicate.  It contains three tokens,
\texttt{p}, a string that names a role, and an integer that specifies
a position within the trace of the role.  That is, for role~$r$ with a
trace of length~$n$, there are~$n$ role position predicates,
\mbox{\texttt{p} $r$ $i$}, for $0\leq i < n$.  The second line gives
the syntax of a role parameter predicate.  It contains three tokens,
\texttt{p}, a string that names a role, and a string that names a role
variable.  For role~$r$, there is role parameter predicate for each
variable declared by~$r$.

When a variable of sort \sym{node} occurs in a formula, its position
must be specified using a role position formula.  When an algebra
variable occurs in formula, its association with the parameter of some
role must be specified using a role parameter formula.

\begin{table}
\begin{center}
  \begin{tabular}{lcl}
    Symbol & Sort & Description\\
    \hline
    \scshape\sym{p} role pos & \dom{node} & \mbox{Role position} \\
    \scshape\sym{p} role param & $\dom{node}\times\dom{mesg}$
    & \mbox{Role parameter} \\
    \sym{str-prec}& $\dom{node}\times\dom{node}$
    & \mbox{Precedes on strand} \\
    \sym{prec}& $\dom{node}\times\dom{node}$
    & \mbox{Precedes} \\
    \sym{non}& \dom{atom}
    & \mbox{Non-origination} \\
    \sym{pnon}& \dom{atom}
    & \mbox{Penetrator non-origination} \\
    \sym{uniq}& \dom{atom}
    & \mbox{Unique origination} \\
    \sym{uniq-at}& $\dom{atom}\times\dom{node}$
    & \mbox{Unique origination at node} \\
    $=$ & $\dom{all}\times\dom{all}$ & Equality
  \end{tabular}
\end{center}
\caption{Predicates}\label{tab:predicates}
\end{table}

\section{Semantics}\label{sec:semantics}

In a \texttt{defgoal} sentence, the antecedent specifies the point of
view skeleton.  We focus on the antecedent.  In the example,

\begin{quote}
\begin{verbatim}
(defstrand init 3 (a a) (b b) (n1 n1) (n2 n2))
\end{verbatim}
\end{quote}
is extracted from
\begin{quote}
\begin{verbatim}
(and (p "init" 2 z0) (p "init" "n1" z0 n1)
     (p "init" "a" z0 a) (p "init" "b" z0 b)).
\end{verbatim}
\end{quote}
Notice that {\cpsa} adds a binding for \texttt{n2} just as it does
had 
\begin{quote}
\begin{verbatim}
(defstrand init 3 (a a) (b b) (n1 n1))
\end{verbatim}
\end{quote}
been given as input.

Our aim now is to specify how to decide if a security goal is true in
all possible executions of a protocol.  A skeleton defines a set of
executions that contain the skeleton's structure.  We say a skeleton
\emph{satisfies} a formula if the formula is true in all executions
that contain the skeleton's structure.  To decide if a skeleton
satisfies a formula, we decide if it satisfies each of its atomic
formulas, and combine the results using the rules of first-order
logic.

Atomic formula \texttt{(p "init" 2 z0)} is called a role position
formula.  A skeleton~$k$ satisfies the formula if \texttt{z0} maps to
a node $n=(s,2)$ in~$k$ such that
\begin{enumerate}
\item the trace of strand~$s$ in~$k$ has a length greater than 2, and
\item the trace when truncated to length 3 is an instance of the init
  role.
\end{enumerate}
Consider the shape in Figure~\ref{fig:ns init}.  It satisfies
\texttt{(p "init" 2 z0)} when \texttt{z0} maps to $(0,2)$.

Atomic formula \texttt{(p "init" "n1" z0 n1)} is called a role
parameter formula.  A skeleton~$k$ satisfies the formula if
\texttt{z0} maps to a node $n=(s,i)$ in~$k$ and \texttt{n1} maps to a
message algebra term~$t$ in~$k$ such that
\begin{enumerate}
\item the trace of strand~$s$ in~$k$ has a length greater than~$i$,
\item the trace truncated to length $i+1$ is an instance of the
  init role, and
\item the truncated trace is compatible with mapping the init role's
  \texttt{"a"} parameter to~$t$.
\end{enumerate}
The shape in Figure~\ref{fig:ns init} satisfies \texttt{(p "init" "n1"
  z0 n1)} when \texttt{z0} maps to $(0,2)$ and \texttt{n1} maps to the
message algebra term \texttt{n1}.

Collectively, a skeleton satisfies the formula
\begin{quote}
\begin{verbatim}
(and (p "init" 2 z0)
     (p "init" "a" z0 a) (p "init" "b" z0 b)
     (p "init" "n1" z0 n1) (p "init" "n2" z0 n2))
\end{verbatim}
\end{quote}
if the skeleton contains the structure specified by
\begin{quote}
\begin{verbatim}
(defstrand init 3 (a a) (b b) (n1 n1) (n2 n2))
\end{verbatim}
\end{quote}

The antecedent in Figure~\ref{fig:ns init} contains two origination
assertions.  The formula \texttt{(non (privk b))} is extracted as
\texttt{(privk b)}.  A skeleton~$k$ satisfies the formula if
\texttt{b} maps to a message algebra term~$t$ in~$k$ such that~$k$
assumes that~$t$ is non-originating.  The unique origination formula for
\texttt{n1} is similarly extracted.

Putting it all together, the mapping
\[\{\mathtt{n1}\mapsto\mathtt{n1},
\mathtt{n2}\mapsto\mathtt{n2}, \mathtt{a}\mapsto\mathtt{a},
\mathtt{b}\mapsto\mathtt{b},\mbox{\tt z0}\mapsto(0,2)\}\] shows that
the shape in Figure~\ref{fig:ns init} satisfies the antecedent of the
security goal.

\emph{explain uniq-at}

\emph{explain prec and str-prec}

Assuming the declarations \texttt{()} the shape in Figure~\ref{fig:ns
  init} could have been extracted from
\begin{quote}
\begin{verbatim}
Bla
\end{verbatim}
\end{quote}

The shape has two node orderings, \texttt{((0 0) (1 0))} and
\texttt{((1 1) (0 1))}.  The second ordering is encoded as
\begin{quote}
\begin{verbatim}
(and (p "init" 1 z-1) (p "resp" 1 z-3) (prec z-3 z-1))
\end{verbatim}
\end{quote}
The two role position formulas assert that \texttt{z-1} and
\texttt{z-3} are located at the second position of a strand, and the
\texttt{prec} formula asserts that \texttt{z-3} is before
\texttt{z-1}.  Any skeleton that satisfies the conjunction must
contain this structure.

A shape analysis sentences asserts that either a skeleton does not
satisfy its antecedent or it satisfies one or more of the disjuncts in
its conclusion.  {\cpsa} has been designed so that this assertion is
true.  Therefore, every shape analysis sentence is true in all
executions.

A security goal is true in all executions if it can be derived from a
shape analysis sentence~\cite{Ramsdell12}.  {\cpsa} comes with a
Prolog program that translates shape analysis sentences into Prover9
syntax~\cite{prover9}.  Prover9 can then be used to perform the
required theorem-proving.

In practice, theorem-proving using shape analysis sentences is rarely
employed.  It's clumsy and it requires too much expertise.  And there
is a better way, via satisfaction-checking.  This is the subject of
the next section.  The main use of \texttt{cpsasas} is for generating
a formula that is edited to become a desired security goal.

\texttt{(uniq-at n1 z)}.  The \texttt{cpsasas} program notices that
\texttt{n1} originates at $(0,0)$ in the input strand.  We require
that any skeleton that satisfies the formula contains this structure.
That is, it is not enough that every skeleton that satisfies the
formula has a corresponding uniquely originating atom, but that atom
must originate at a particular position and on a particular strand.
Therefore, \texttt{cpsasas} adds \texttt{(p "init" 0 z)} and
\texttt{(str-prec z z-0)}.  The first formula asserts that \texttt{z}
is at the first position of a strand, and the second formula asserts
that \texttt{z} is before \texttt{z-0} and on the same strand.

\section{Posing Goals in an Input Skeleton}\label{sec:posing}

{\cpsa} performs satisfaction-checking when an input goal in annotated
with one or more security goals.  The annotation uses the
\texttt{goals} key.

\begin{quote}
  \begin{alltt}
(defskeleton
   \ldots
   (goals \textsc{sent\ensuremath{+}}))
  \end{alltt}
\end{quote}

When the input skeleton in Figure~\ref{fig:ns init} is annotated with
its shape analysis sentence, {\cpsa} will check if the generated shape
satisfies the goal.  Of course, it will be, so {\cpsa} adds
\texttt{(satisfies yes)} to the shape to indicate that the shape
satisfies the goal.

Consider an analysis of Needham-Schroeder from the responder point of view.
\begin{quote}
  \begin{alltt}
(defskeleton ns
  (vars (a name) (n2 text))
  (defstrand resp 3 (a a) (n2 n2))
  (non-orig (privk a))
  (uniq-orig n2)
  (goals \(\Phi\)))
  \end{alltt}
\end{quote}
where \(\Phi\) is the shape analysis sentence in Figure~\ref{fig:ns
  init}.  {\cpsa} will report that the generated shape satisfies the
goal because it does not satisfy the antecedent of~\(\Phi\).

Consider the goal \(\Psi\) which is~\(\Phi\) with the conclusion replaced
by \texttt{(false)}.  The responder point of view shape satisfies this
goal, but the initiator point of view shape does not.  In this case,
{\cpsa} annotates the shape with
\begin{quote}
\begin{verbatim}
(satisfies (no (n1 n1) (n2 n2) (a a) (b b)
               (z (0 0)) (z-0 (0 2))))
\end{verbatim}
\end{quote}
The output shows a variable mapping for a shape that satisfies the
antecedent of the goal but does not satisfy its conclusion.

\section{Specifying an Input Skeleton by a Goal}\label{sec:specifying}

Recall that our aim in analyzing a protocol is to find out what
security goals are true in all of its possible executions.  We are
interested in runs of {\cpsa} that show that when every shape
satisfies a goal, it is true in every execution.

When {\cpsa} performs a shape analysis, every shape it generates
refines the input skeleton.  Skeleton refinement is defined
in~\cite[Section~6]{cpsaprimer09}, but roughly speaking, skeleton~$A$
refines skeleton~$B$ if~$A$ contains the structure of skeleton~$B$.

Shape analysis sentences have the property that every skeleton that
refines its input skeleton satisfies its antecedent.  A skeleton with
this property is called the \emph{characteristic skeleton} of the
antecedent.

Given a goal~\(\Phi\), consider a shape analysis starting from the
characteristic skeleton~$k_0$ of its antecedent.  Assume {\cpsa} finds
shapes $k_1,\ldots,k_n$ and that {\cpsa} determines that each~$k_i$
satisfies~$\Phi$.  Consider the executions that contain the structure
in~$k_0$.  {\cpsa} tells us that each execution is in the executions
that contain the structure of some~$k_i$.  Furthermore, because~$k_0$
is a characteristic skeleton, each~$k_i$ satisfies the antecedent
of~$\Phi$.  Therefore,~$\Phi$ is true in all executions of the
protocol and maximally informative.

{\cpsa} provides a means for constructing a characteristic skeleton
from a security goal using the top-level \texttt{defgoal} form.

\begin{center}\scshape
  \begin{tabular}{rcl}
  goal&$\leftarrow$&(\sym{defgoal} prot sent$+$ goal-alist)
  \end{tabular}
\end{center}

When {\cpsa} reads a \texttt{defgoal} form, it extracts the
characteristic skeleton from the antecedent of the first goal, and
adds all the goals as \texttt{goals} annotation.  It then processes
the skeleton as described in Section~\ref{sec:posing}.  The goal alist
can be used to add a comment.

\begin{figure}
\begin{quote}
\begin{verbatim}
(defgoal ns
  (forall ((a b name) (n text) (z0 node))
    (implies
     (and (p "init" 1 z0) (p "init" "n1" z0 n)
      (p "init" "a" z0 a) (p "init" "b" z0 b)
      (non (privk a)) (non (privk b)) (uniq n))
     (exists ((z1 node))
      (and (p "resp" 1 z1) (p "resp" "b" z1 b)))))
  (forall ((a b name) (n text) (z0 node))
   (implies
     (and (p "init" 1 z0) (p "init" "n1" z0 n)
      (p "init" "a" z0 a) (p "init" "b" z0 b)
      (non (privk a)) (non (privk b)) (uniq n))
     (exists ((z1 node))
      (and (p "resp" 1 z1) (p "resp" "a" z1 a))))))
\end{verbatim}
\end{quote}
\caption{Two Initiator Authentication Goals}\label{fig:ns init goals}
\end{figure}

Consider the task of determining if the Needham-Schroeder Protocol
achieves various authentication goals.  From the point of view of an
initiator run, let's see if the strands agree on their names.
Figure~\ref{fig:ns init goals} shows the input.  The first goal checks
to see if the strands agree on the \texttt{a} parameter and the second
goal checks to see if the strands agree on the \texttt{b} parameter.
The antecedent of both goals is copied from the shape analysis
sentence in Figure~\ref{fig:ns init}.  The antecedent has been
simplified by omitting the node at which \texttt{n} originates and
instead asserts just \texttt{(uniq n)}.  The input skeleton generated
is the same as the one in Figure~\ref{fig:ns init}.  The shape
produced by {\cpsa} includes the annotation \texttt{(satisfies yes
  yes)} stating that both goals are achieved.

\begin{figure}
\begin{quote}
\begin{verbatim}
(defgoal ns             ; Input
  (forall ((a b name) (n text) (z0 node))
   (implies
    (and (p "resp" 2 z0) (p "resp" "n2" z0 n)
     (p "resp" "a" z0 a) (p "resp" "b" z0 b)
     (non (privk a)) (non (privk b)) (uniq n))
    (exists ((z1 node))
     (and (p "init" 2 z1) (p "init" "a" z1 a)))))
  (forall ((a b name) (n text) (z0 node))
   (implies
    (and (p "resp" 2 z0) (p "resp" "n2" z0 n)
     (p "resp" "a" z0 a) (p "resp" "b" z0 b)
     (non (privk a)) (non (privk b)) (uniq n))
    (exists ((z1 node))
     (and (p "init" 2 z1) (p "init" "b" z1 b))))))

(defskeleton ns         ; Shape
  (vars (n n1 text) (a b b-0 name))
  (defstrand resp 3 (n2 n) (n1 n1) (b b) (a a))
  (defstrand init 3 (n1 n1) (n2 n) (a a) (b b-0))
  (precedes ((0 1) (1 1)) ((1 2) (0 2)))
  (non-orig (privk a) (privk b))
  (uniq-orig n)
  (satisfies yes (no (a a) (b b) (n n) (z0 (0 2)))))
\end{verbatim}
\end{quote}
\caption{Two Responder Authentication Goals}\label{fig:ns resp goals}
\end{figure}

Let's see if the strands agree on their names from the point of view
of a responder run.  Figure~\ref{fig:ns resp goals} shows the input
and the shape.  The first goal checks to see if the strands agree on
the \texttt{a} parameter and the second goal checks to see if the
strands agree on the \texttt{b} parameter.  The shape produced by
{\cpsa} includes the annotation \texttt{(satisfies yes (no (a a) (b b)
  (n n) (z0 (0 2))))} stating that the second goal is not achieved.
The output includes a variable mapping for the shape that
satisfies the antecedent of the goal but does not satisfy its
conclusion.  The mapping \texttt{(b b)} is the reason the shape
does not satisfy the goal.

\section{Comparing Protocols with Security Goals}\label{sec:comparing}

We conclude with an example of using {\cpsa}'s support for security
goals to compare the strength of protocols as described
in~\cite{GuttmanLiskovRowe14}.  The strength comparison paper uses
security goals as defined in~\cite{Guttman14}.  We call the goal
language in~\cite{Guttman14} the \emph{restricted} goal language for
reasons that will become apparent later.

The restricted goal language and the {\cpsa} goal language are very
similar, indeed, the restricted goal language motivated the {\cpsa}
language.  The two languages differ in several small ways.  For
example, node orderings are specified using the \texttt{preceq} in the
restricted goal language, but since {\cpsa} implements a strict
partial ordering among nodes, its goal language uses \texttt{prec}.
Also, role position and role parameter predicates are assigned a
symbol.  The use of a well chosen mnemonic symbol makes formulas
easier to understand.

The essential difference between the two languages is in the sort
of role parameter predicates.  In the restricted language, the message
term is restricted to be an atom.
\begin{center}
  \begin{tabular}{ccc}
    Symbol & Restricted & \cpsa\\
    \hline
    \scshape\sym{p} role param &
    $\dom{node}\times\dom{atom}$ &
    $\dom{node}\times\dom{mesg}$
  \end{tabular}
\end{center}
This restriction is enforced so that protocols can be compared without
exposing the encryption and pairing structure that makes up messages.

Our example focuses on unilateral authentication.  To best understand
this example, process the sample file \texttt{goal.scm} with {\cpsa}
and display its output in a browser.

The protocol and its goal is shown in Figure~\ref{fig:unilateral}.
When given as input, {\cpsa} verifies that the goal is true in all
executions of the protocol.

\begin{figure}
\begin{minipage}{2.7in}
\begin{verbatim}
(defprotocol unilateral basic
  (defrole init
     (vars (a name) (n text))
     (trace
      (send (enc n (pubk a)))
      (recv n)))
  (defrole resp
     (vars (a name) (n text))
     (trace
      (recv (enc n (pubk a)))
      (send n))))
\end{verbatim}
\end{minipage}\hfil
\begin{minipage}{3.0in}
\begin{verbatim}
(defgoal unilateral
  (forall ((a name) (n text)
           (z0 node))
   (implies
    (and (p "init" 1 z0)
     (p "init" "n" z0 n)
     (p "init" "a" z0 a)
     (non (privk a)) (uniq n))
    (exists ((z1 node))
     (and (p "resp" 1 z1)
      (p "resp" "a" z1 a))))))
\end{verbatim}
\end{minipage}
\caption{Unilateral Protocol and Authentication Goal}\label{fig:unilateral}
\end{figure}

\begin{figure}
\begin{quote}
\begin{verbatim}
(defgoal ns
  (forall ((a name) (n text) (z0 node))
   (implies
    (and (p "init" 1 z0) (p "init" "n1" z0 n)
     (p "init" "b" z0 a) (non (privk a)) (uniq n))
    (exists ((z1 node))
     (and (p "resp" 1 z1) (p "resp" "b" z1 a))))))
\end{verbatim}
\end{quote}
\caption{Translated Unilateral Goal for the
  Initiator}\label{fig:unilateral ns init}
\end{figure}

\begin{figure}
\begin{quote}
\begin{verbatim}
(defgoal ns
  (forall ((a name) (n text) (z0 node))
   (implies
    (and (p "resp" 2 z0) (p "resp" "n2" z0 n)
     (p "resp" "a" z0 a) (non (privk a)) (uniq n))
    (exists ((z1 node))
     (and (p "init" 2 z1) (p "init" "a" z1 a)))))
\end{verbatim}
\end{quote}
\caption{Translated Unilateral Goal for the
  Responder}\label{fig:unilateral ns resp}
\end{figure}

Let's compare this protocol with Needham-Schroeder.  Consider the goal
in Figure~\ref{fig:unilateral ns init}.  This goal is the result of
translating the Unilateral role position and parameter predicates as
follows.
\begin{center}
\begin{tabular}{l@{$\quad\rightarrow\quad$}l}
  \texttt{p "init" "n"}&\texttt{p "init" "n1"}\\
  \texttt{p "init" "a"}&\texttt{p "init" "b"}\\
  \texttt{p "resp" "a"}&\texttt{p "resp" "b"}
\end{tabular}
\end{center}
When given Figure~\ref{fig:unilateral ns init} as input, {\cpsa}
verifies that the goal is true in all executions of the protocol.

There is another way to translate the Unilateral goal.
\begin{center}
\begin{tabular}{l@{$\quad\rightarrow\quad$}l}
  \texttt{p "init" 1}&\texttt{p "resp" "2"}\\
  \texttt{p "init" "n"}&\texttt{p "resp" "n2"}\\
  \texttt{p "init" "a"}&\texttt{p "resp" "a"}\\
  \texttt{p "resp" "1"}&\texttt{p "init" "2"}\\
  \texttt{p "resp" "a"}&\texttt{p "init" "a"}
\end{tabular}
\end{center}
When given Figure~\ref{fig:unilateral ns resp} as input, {\cpsa}
verifies that the goal is true in all executions of the protocol.

{\cpsa} has demonstrated two ways in which Needham-Schroeder achieves
the goals of the Unilateral Protocol.

\bibliography{cpsa}
\bibliographystyle{plain}

\end{document}
