\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{alltt}
\input{macros}

\newcommand{\sym}[1]{\textup{\texttt{#1}}}

\title{CPSA and Formal Security Goals}
\author{John D.~Ramsdell\\
  The MITRE Corporation\\ CPSA Version \version}

\begin{document}
\maketitle
\cpsacopying

\tableofcontents

\listoffigures

\listoftables

\newpage

\section{Introduction}

\begin{sloppypar}
Analyzing a cryptographic protocol means finding out what security
properties---essentially, authentication and secrecy properties---are
true in all its possible executions.
\end{sloppypar}

Given a protocol definition and some assumptions about executions,
{\cpsa} attempts to produce descriptions of all possible executions of
the protocol compatible with the assumptions.  Naturally, there are
infinitely many possible executions of a useful protocol, since
different participants can run it with varying parameters, and the
participants can run it repeatedly.

However, for many naturally occurring protocols, there are only
finitely many of these runs that are essentially different.  Indeed,
there are frequently very few, often just one or two, even in cases
where the protocol is flawed.  We call these essentially different
executions the \emph{shapes} of the protocol.  Authentication and
secrecy properties are easy to ``read off'' from the shapes, as are
attacks and anomalies, according to the introduction in the {\cpsa}
Primer~\cite{cpsaprimer09}.

But how easy is it to read off authentication and secrecy properties?
What precisely is it that an expert sees?  This paper describes
{\cpsa}'s support for reasoning about security goals using first-order
logic.  With security goals expressed in first-order logic, intuition
is replaced by satisfaction-checking and theorem-proving.

This treatment of security goals relies heavily on a branch of
first-order logic called model theory.  It deals with the relationship
between descriptions in first-order languages and the structures that
satisfy these descriptions.  In our case, the structures are skeletons
that denote a collection of executions of a protocol.  This paper
attempts to describe the language of security goals and its
structures without requiring the reader to have studied model theory.

The {\cpsa} Primer~\cite{cpsaprimer09} is a prerequisite for reading
this paper.  In particular, the analysis of the Needham-Schroeder
protocol in Section~10 is enriched with security goals in the body of
this paper.

The paper has three main sections.  Section~\ref{sec:sas} introduces
the syntax and semantics of formal security goals using shape analysis
sentences.  A shape analysis sentence expresses all that can be
learned from a run of {\cpsa} in our language of security goals.  If a
security goal can be derived from a shape analysis sentence, then the
protocol achieves the security goal, that is, the goal is true in all
executions of the protocol.

Theorem-proving is inconvenient.  Section~\ref{sec:posing} explains
how to annotate an input skeleton with a security goal.  For each
shape that {\cpsa} finds, it uses the semantics of the goal language
to determine if the goal is true in all executions described by the
shape.  If the goal has a certain form, the truth of the goal can be
extended to all executions.

Section~\ref{sec:specifying} presents the top-level \texttt{defgoal}
form that specifies a security goal for a protocol.  {\cpsa} extracts
an input skeleton from the goal, and then annotates the input skeleton
with the goal.  {\cpsa} processes this input skeleton as described in
Section~\ref{sec:posing}.  The derived skeleton has the property that
when the goal is true in all executions described by all of its shapes,
it is true of all executions of the protocol.

The model theoretical foundation of this approach to security goals
appears in~\cite{Guttman14}.  The language of security goals differs
slightly from what is present here.  Section~\ref{sec:specifying}
contains a discussion on the differences between the two goal
languages.  Shape analysis sentences were introduced
in~\cite{Ramsdell12}.  A practical use of security goals in protocol
standardization is described in~\cite{GuttmanLiskovRowe14}.  The
precise semantics of the goal language is in~\cite{cpsaspec09}.  The
syntax of security goals appears in~\cite[Table~2]{cpsaprimer09}.

The distribution in which this paper is included contains the sample
input {\cpsa} file \texttt{goals.scm}.  It contains the examples in
this paper.  You are encouraged to run the examples and examine the
output while reading this paper.

\section{Shape Analysis Sentences}\label{sec:sas}
%% Use a margin width of 62 for S-expressions

\begin{figure}
\begin{center}
\includegraphics{cpsadiagrams-0.mps}\hfil
\includegraphics{cpsadiagrams-1.mps}\\
\end{center}
\begin{center}
\begin{minipage}{3in}
\begin{verbatim}
(defprotocol ns basic
  (defrole init
    (vars (a b name) (n1 n2 text))
    (trace
     (send (enc n1 a (pubk b)))
     (recv (enc n1 n2 (pubk a)))
     (send (enc n2 (pubk b)))))
  (defrole resp
    (vars (b a name) (n2 n1 text))
    (trace
     (recv (enc n1 a (pubk b)))
     (send (enc n1 n2 (pubk a)))
     (recv (enc n2 (pubk b))))))
\end{verbatim}
\end{minipage}
\end{center}
\caption{Needham-Schroeder Initiator and Responder Roles}
\label{fig:ns roles}
\end{figure}

\begin{figure}
\begin{verbatim}
(defskeleton ns            ; Input skeleton
  (vars (a b name) (n1 text))
  (defstrand init 3 (a a) (b b) (n1 n1))
  (non-orig (privk b) (privk a))
  (uniq-orig n1))
\end{verbatim}
\begin{center}
\includegraphics{cpsadiagrams-5.mps}
\end{center}
\begin{verbatim}
(defskeleton ns            ; Shape
  (vars (n1 n2 text) (a b name))
  (defstrand init 3 (n1 n1) (n2 n2) (a a) (b b))
  (defstrand resp 2 (n2 n2) (n1 n1) (b b) (a a))
  (precedes ((0 0) (1 0)) ((1 1) (0 1)))
  (non-orig (privk b) (privk a))
  (uniq-orig n1))

(defgoal ns                ; Shape analysis sentence
  (forall ((n1 n2 text) (a b name) (z z-0 node))
    (implies
      (and (p "init" 0 z) (p "init" 2 z-0)
        (p "init" "n1" z-0 n1) (p "init" "n2" z-0 n2)
        (p "init" "a" z-0 a) (p "init" "b" z-0 b)
        (str-prec z z-0) (non (privk a)) (non (privk b))
        (uniq-at n1 z))
      (exists ((z-1 z-2 z-3 node))
        (and (p "init" 1 z-1) (p "resp" 0 z-2)
          (p "resp" 1 z-3) (p "resp" "n2" z-3 n2)
          (p "resp" "n1" z-3 n1) (p "resp" "b" z-3 b)
          (p "resp" "a" z-3 a) (prec z z-2) (prec z-3 z-1)
          (str-prec z z-1) (str-prec z-1 z-0)
          (str-prec z-2 z-3))))))
\end{verbatim}
\caption{Needham-Schroeder Initiator Point of View}
\label{fig:ns init}
\end{figure}

The easiest way to get started with security goals is to use the
\texttt{cpsasas} program to generate a goal.  Recall the analysis of
the Needham-Schroeder Protocol in~\cite[Section~10]{cpsaprimer09}.
The roles are displayed in Figure~\ref{fig:ns roles}.

The protocol is analyzed from the point of view of a complete run of
one instance of an initiator role.

\begin{quote}
\begin{verbatim}
(defskeleton ns
  (vars (a b name) (n1 text))
  (defstrand init 3 (a a) (b b) (n1 n1))
  (non-orig (privk b) (privk a))
  (uniq-orig n1))
\end{verbatim}
\end{quote}

This {\cpsa} input is at the beginning of the sample file
\texttt{goals.scm}.  To generate a security goal from the initiator
point of view with \texttt{ghci} and \texttt{Make.hs}, type
\begin{quote}
\begin{verbatim}
$ ghci Make.hs
*Make> sas "goals"
\end{verbatim}
\end{quote}
When using GNU make, type ``\texttt{make goals\_sas.text}''.  The
resulting shape analysis and its sentence is displayed in
Figure~\ref{fig:ns init}.

The sentence has a form shared by all security goals.  It is a
universally quantified implication.  The antecedent is a conjunction
of atomic formulas.  For this sentence, the conclusion is an
existentially quantified conjunction of atomic formulas, but in
general, the conclusion is a disjunction of existentially quantified
conjunctions of atomic formulas.  \sym{(false)} is a synonym for
\sym{(or)}.

\begin{center}\scshape
  \begin{tabular}{rcl}
  sent&$\leftarrow$&(\sym{forall} (decl$\ast$) (\sym{implies} antec concl))
  \\ concl&$\leftarrow$&(\sym{false})
  $\mid$ existl $\mid$ (\sym{or} existl$\ast)$
  \\ existl&$\leftarrow$&(\sym{exists}
  (decl$\ast$) antec) $\mid$ antec
  \\ antec&$\leftarrow$&atomic $\mid$ (\sym{and} atomic$\ast$)
  \end{tabular}
\end{center}
The predicate symbols used to construct an atomic formula
(\textsc{atomic}) are listed in Table~\ref{tab:predicates}.

Variables are declared as they are for roles and skeletons with one
exception, there is a new sort symbol \sym{node}.  Notice that in the
sentence, variables \sym{z} and \sym{z-0} have sort \sym{node}.  Every
universally quantified variable must occur in the antecedent of the
implication.

\begin{table}
\begin{center}
  \begin{tabular}{lcl}
    Symbol & Sort & Description\\
    \hline
    \scshape\sym{p} role pos & \dom{node} & \mbox{Role position} \\
    \scshape\sym{p} role param & $\dom{node}\times\dom{mesg}$
    & \mbox{Role parameter} \\
    \sym{str-prec}& $\dom{node}\times\dom{node}$
    & \mbox{Precedes on strand} \\
    \sym{prec}& $\dom{node}\times\dom{node}$
    & \mbox{Precedes} \\
    \sym{non}& \dom{atom}
    & \mbox{Non-origination} \\
    \sym{pnon}& \dom{atom}
    & \mbox{Penetrator non-origination} \\
    \sym{uniq}& \dom{atom}
    & \mbox{Unique origination} \\
    \sym{uniq-at}& $\dom{atom}\times\dom{node}$
    & \mbox{Unique origination at node} \\
    $=$ & $\dom{all}\times\dom{all}$ & Equality
  \end{tabular}
\end{center}
\caption{Predicates}\label{tab:predicates}
\end{table}

In a shape analysis sentence, the antecedent encodes the input
skeleton, and each disjunct in the conclusion encodes a shape.
We focus on the antecedent.  In this example,

\begin{quote}
\begin{verbatim}
(defstrand init 3 (a a) (b b) (n1 n1) (n2 n2))
\end{verbatim}
\end{quote}
is encoded as
\begin{quote}
\begin{verbatim}
(and (p "init" 2 z-0)
     (p "init" "a" z-0 a) (p "init" "b" z-0 b)
     (p "init" "n1" z-0 n1) (p "init" "n2" z-0 n2))
\end{verbatim}
\end{quote}

Our aim now is to specify how to decide if a security goal is true in
all possible executions of a protocol.  A skeleton defines a set of
executions that contain the skeleton's structure.  We say a skeleton
\emph{satisfies} a formula if the formula is true in all executions
that contain the skeleton's structure.  To decide if a skeleton
satisfies a formula, we decide if it satisfies each of its atomic
formulas, and combine the results using the rules of first-order
logic.

Atomic formula \texttt{(p "init" 2 z-0)} is called a role position
formula.  A skeleton~$k$ satisfies the formula if \texttt{z-0} maps to
a node $n=(s,2)$ in~$k$ such that
\begin{enumerate}
\item the trace of strand~$s$ in~$k$ has a length greater than 2, and
\item the trace when truncated to length 3 is an instance of the init
  role.
\end{enumerate}
Consider the shape in Figure~\ref{fig:ns
  init}.  It satisfies \texttt{(p "init" 2 z-0)} when \texttt{z-0}
maps to $(0,2)$.

Atomic formula \texttt{(p "init" "a" z-0 a)} is called a role
parameter formula.  A skeleton~$k$ satisfies the formula if
\texttt{z-0} maps to a node $n=(s,i)$ in~$k$ and \texttt{a} maps to a
message algebra term~$t$ in~$k$ such that
\begin{enumerate}
\item the trace of strand~$s$ in~$k$ has a length greater than~$i$,
\item the trace truncated to length $i+1$ is an instance of the
  init role, and
\item the truncated trace is compatible with mapping the init role's
  \texttt{"a"} parameter to~$t$.
\end{enumerate}
The shape in Figure~\ref{fig:ns init} satisfies \texttt{(p "init" "a"
  z-0 a)} when \texttt{z-0} maps to $(0,2)$ and \texttt{a} maps to the
message algebra term \texttt{a}.

Collectively, a skeleton satisfies the formula
\begin{quote}
\begin{verbatim}
(and (p "init" 2 z-0)
     (p "init" "a" z-0 a) (p "init" "b" z-0 b)
     (p "init" "n1" z-0 n1) (p "init" "n2" z-0 n2))
\end{verbatim}
\end{quote}
if the skeleton contains the structure specified by
\begin{quote}
\begin{verbatim}
(defstrand init 3 (a a) (b b) (n1 n1) (n2 n2))
\end{verbatim}
\end{quote}

The input skeleton in Figure~\ref{fig:ns init} contains three
origination assumptions.  The assumption on \texttt{(privk b)} is
encoded as \texttt{(non (privk b))}.  A skeleton~$k$ satisfies the
formula if \texttt{b} maps to a message algebra term~$t$ in~$k$ such
that~$k$ assumes that~$t$ is non-originating.

The origination assumption on \texttt{n1} is encoded as
\texttt{(uniq-at n1 z)}.  The \texttt{cpsasas} program notices that
\texttt{n1} originates at $(0,0)$ in the input strand.  We require
that any skeleton that satisfies the formula contains this structure.
That is, it is not enough that every skeleton that satisfies the
formula has a corresponding uniquely originating atom, but that atom
must originate at a particular position and on a particular strand.
Therefore, \texttt{cpsasas} adds \texttt{(p "init" 0 z)} and
\texttt{(str-prec z z-0)}.  The first formula asserts that \texttt{z}
is at the first position of a strand, and the second formula asserts
that \texttt{z} is before \texttt{z-0} and on the same strand.

Putting it all together, the mapping
\[\{\mathtt{n1}\mapsto\mathtt{n1},
\mathtt{n2}\mapsto\mathtt{n2},
\mathtt{a}\mapsto\mathtt{a},
\mathtt{b}\mapsto\mathtt{b},
\mathtt{z}\mapsto(0,0),
\mbox{\tt z-0}\mapsto(0,2)\}\]
shows that the shape in Figure~\ref{fig:ns init} satisfies the
antecedent of the shape analysis sentence.

The shape has two node orderings, \texttt{((0 0) (1 0))} and
\texttt{((1 1) (0 1))}.  The second ordering is encoded as
\begin{quote}
\begin{verbatim}
(and (p "init" 1 z-1) (p "resp" 1 z-3) (prec z-3 z-1))
\end{verbatim}
\end{quote}
The two role position formulas assert that \texttt{z-1} and
\texttt{z-3} are located at the second position of a strand, and the
\texttt{prec} formula asserts that \texttt{z-3} is before
\texttt{z-1}.  Any skeleton that satisfies the conjunction must
contain this structure.

A shape analysis sentences asserts that either a skeleton does not
satisfy its antecedent or it satisfies one or more of the disjuncts in
its conclusion.  {\cpsa} has been designed so that this assertion is
true.  Therefore, every shape analysis sentence is true in all
executions.

A security goal is true in all executions if it can be derived from a
shape analysis sentence~\cite{Ramsdell12}.  {\cpsa} comes with a
Prolog program that translates shape analysis sentences into Prover9
syntax~\cite{prover9}.  Prover9 can then be used to perform the
required theorem-proving.

In practice, theorem-proving using shape analysis sentences is rarely
employed.  It's clumsy and it requires too much expertise.  And there
is a better way, via satisfaction-checking.  This is the subject of
the next section.  The main use of \texttt{cpsasas} is for generating
a formula that is edited to become a desired security goal.

\section{Specifying an Input Skeleton by a Goal}\label{sec:specifying}

\emph{protocol transformations}

\emph{Restricting parameter preds to apply to atoms instead of all messages}

\section{Posing Goals in an Input Skeleton}\label{sec:posing}

\section{Conclusion}\label{sec:conclusion}

\bibliography{cpsa}
\bibliographystyle{plain}

\end{document}
