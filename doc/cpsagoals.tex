\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{url}
\usepackage{graphicx}
\usepackage{alltt}
\input{macros}

\newcommand{\sym}[1]{\textup{\texttt{#1}}}

\title{CPSA and Formal Security Goals}
\author{John D.~Ramsdell\\
  The MITRE Corporation\\ CPSA Version \version}

\begin{document}
\maketitle
\cpsacopying

\tableofcontents

\listoffigures

\listoftables

\newpage

\section{Introduction}

\begin{sloppypar}
Analyzing a cryptographic protocol means finding out what security
properties---essentially, authentication and secrecy properties---are
true in all its possible executions.
\end{sloppypar}

Given a protocol definition and some assumptions about executions,
{\cpsa} attempts to produce descriptions of all possible executions of
the protocol compatible with the assumptions.  Naturally, there are
infinitely many possible executions of a useful protocol, since
different participants can run it with varying parameters, and the
participants can run it repeatedly.

However, for many naturally occurring protocols, there are only
finitely many of these runs that are essentially different.  Indeed,
there are frequently very few, often just one or two, even in cases
where the protocol is flawed.  We call these essentially different
executions the \emph{shapes} of the protocol.  Authentication and
secrecy properties are easy to ``read off'' from the shapes, as are
attacks and anomalies, according to the introduction in the {\cpsa}
Primer~\cite{cpsaprimer09}.

But how easy is it to read off authentication and secrecy properties?
What precisely is it that an expert sees?  This paper describes
{\cpsa}'s support for reasoning about security goals using first-order
logic.  With security goals expressed in first-order logic, intuition
is replaced by satisfaction-checking and theorem-proving.

The {\cpsa} Primer~\cite{cpsaprimer09} is a prerequisite for reading
this paper.  In particular, the analysis of the Needham-Schroeder
protocol in Section~10 is enriched with security goals in the body of
this paper.

The paper has three main sections.  Section~\ref{sec:sas} introduces
the syntax and semantics of formal security goals using shape analysis
sentences.  A shape analysis sentence expresses all that can be
learned from a run of {\cpsa} in our language of security goals.  If a
security goal can be derived from a shape analysis sentence, then the
protocol achieves the security goal, that is, the goal is true in all
executions of the protocol.

Theorem-proving is inconvenient.  Section~\ref{sec:posing} explains
how to annotate an input skeleton with a security goal.  For each
shape that {\cpsa} finds, it uses the semantics of the goal language
to determine if the goal is true in all executions described by the
shape.  If the goal has a certain form, the truth of the goal can be
extended to all executions.

Section~\ref{sec:specifying} presents the top-level \texttt{defgoal}
form that specifies a security goal for a protocol.  {\cpsa} extracts
an input skeleton from the goal, and then annotates the input skeleton
with the goal.  {\cpsa} processes this input skeleton as described in
Section~\ref{sec:posing}.  The derived skeleton has the property that
when the goal is true in all executions described by all of its shapes,
it is true of all executions of the protocol.

The theoretical foundation of this approach to security goals appears
in~\cite{Guttman14}.  Section~\ref{sec:sas} ends with a discussion on
the differences between the two goal languages.  Shape analysis
sentences were introduced in~\cite{Ramsdell12}.  A practical use of
security goals in protocol standardization is described
in~\cite{GuttmanLiskovRowe14}.  The precise semantics of the goal
language is in~\cite{cpsaspec09}.  The syntax of security goals
appears in~\cite[Table~2]{cpsaprimer09}.

The distribution in which this paper is included contains the sample
input {\cpsa} file \texttt{goals.scm}.  It contains the examples in
this paper.  You are encouraged to run the examples and examine the
output while reading this paper.

\section{Shape Analysis Sentences}\label{sec:sas}
%% Use a margin width of 62 for S-expressions

The easiest way to get started with security goals is to use the
\texttt{cpsasas} program to generate a goal.  Recall the analysis of
the Needham-Schroeder Protocol in~\cite[Section~10]{cpsaprimer09}.
The roles are displayed in Figure~\ref{fig:ns roles}.

\begin{figure}
\begin{center}
\includegraphics{cpsadiagrams-0.mps}\hfil
\includegraphics{cpsadiagrams-1.mps}
\caption{Needham-Schroeder Initiator and Responder Roles}
\label{fig:ns roles}
\end{center}
\end{figure}

An S-expression version of Figure~\ref{fig:ns roles} follows.

\begin{verbatim}
(defprotocol ns basic
  (defrole init
    (vars (a b name) (n1 n2 text))
    (trace
     (send (enc n1 a (pubk b)))
     (recv (enc n1 n2 (pubk a)))
     (send (enc n2 (pubk b)))))
  (defrole resp
    (vars (b a name) (n2 n1 text))
    (trace
     (recv (enc n1 a (pubk b)))
     (send (enc n1 n2 (pubk a)))
     (recv (enc n2 (pubk b))))))
\end{verbatim}

The protocol is analyzed from the point of view of a complete run of
one instance of an initiator role.

\begin{verbatim}
(defskeleton ns
  (vars (a b name) (n1 text))
  (defstrand init 3 (a a) (b b) (n1 n1))
  (non-orig (privk b) (privk a))
  (uniq-orig n1))
\end{verbatim}

This {\cpsa} input is at the beginning of the sample file
\texttt{goals.scm}.  To generate a security goal from the initiator
point of view with \texttt{ghci} and \texttt{Make.hs}, type
\begin{quote}
\begin{verbatim}
$ ghci Make.hs
*Make> sas "goals"
\end{verbatim}
\end{quote}
When using GNU make, type ``\texttt{make goals\_sas.text}''.  The
resulting shape analysis sentence follows.

\begin{verbatim}
(defgoal ns
  (forall ((n1 n2 text) (a b name) (z z-0 node))
    (implies
      (and (p "init" 0 z) (p "init" 2 z-0)
        (p "init" "n1" z-0 n1) (p "init" "n2" z-0 n2)
        (p "init" "a" z-0 a) (p "init" "b" z-0 b)
        (str-prec z z-0) (non (privk a)) (non (privk b))
        (uniq-at n1 z))
      (exists ((z-1 z-2 z-3 node))
        (and (p "init" 1 z-1) (p "resp" 0 z-2)
          (p "resp" 1 z-3) (p "resp" "n2" z-3 n2)
          (p "resp" "n1" z-3 n1) (p "resp" "b" z-3 b)
          (p "resp" "a" z-3 a) (prec z z-2) (prec z-3 z-1)
          (str-prec z z-1) (str-prec z-1 z-0)
          (str-prec z-2 z-3))))))
\end{verbatim}

The sentence has a form shared by all security goals.  It is a
universally quantified implication.  The antecedent is a conjunction
of atomic formulas.  For this sentence, the conclusion is an
existentially quantified conjunction of atomic formulas, but in
general, the conclusion is a disjunction of existentially quantified
conjunctions of atomic formulas.  \sym{(false)} is a synonym for
\sym{(or)}.

\begin{center}\scshape
  \begin{tabular}{rcl}
  sent&$\leftarrow$&(\sym{forall} (decl$\ast$) (\sym{implies} antec concl))
  \\ concl&$\leftarrow$&(\sym{false})
  $\mid$ existl $\mid$ (\sym{or} existl$\ast)$
  \\ existl&$\leftarrow$&(\sym{exists}
  (decl$\ast$) antec) $\mid$ antec
  \end{tabular}
\end{center}

Variables are declared as they are for roles and skeletons with one
exception, there is a new sort symbol \sym{node}.  Notice that in the
sentence, variables \sym{z} and \sym{z-0} have sort \sym{node}.  Every
universally quantified variable must occur in the antecedent of the
implication.

In a shape analysis sentence, the antecedent encodes the input
skeleton, and each disjunct in the conclusion encodes a shape.
We focus on the antecedent.  In this example,

\begin{quote}
\begin{verbatim}
(defstrand init 3 (a a) (b b) (n1 n1) (n2 n2))
\end{verbatim}
\end{quote}
is encoded as
\begin{quote}
\begin{verbatim}
(and (p "init" 2 z-0)
     (p "init" "a" z-0 a) (p "init" "b" z-0 b)
     (p "init" "n1" z-0 n1) (p "init" "n2" z-0 n2))
\end{verbatim}
\end{quote}

Our aim now is to specify how to decide if a security goal is true in
all possible executions of a protocol.  A skeleton defines a set of
executions that contain the skeleton's structure.  We say a skeleton
\emph{satisfies} a formula if the formula is true in all executions
that contain the skeleton's structure.  To decide if a skeleton
satisfies a formula, we decide if it satisfies each of its atomic
formulas, and combine the results using the rules of first-order
logic.

Atomic formula \texttt{(p "init" 2 z-0)} is called a role-position
predicate.  

\section{Posing Goals in an Input Skeleton}\label{sec:posing}

\section{Specifying an Input Skeleton by a Goal}\label{sec:specifying}

\section{Conclusion}\label{sec:conclusion}

\bibliography{cpsa}
\bibliographystyle{plain}

\end{document}
